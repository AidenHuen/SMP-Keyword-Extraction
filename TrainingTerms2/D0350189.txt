#利用/vredis/gi缓存/gi解决/v高并发/gi下/f后端/f重复请求/gi措施/gi
  /x最近/t在/p进行/vn压力/n测试/gi的/ude1时候/n发现/v在/p高并发/gi下/f，/w有些/rz接口/gi很可能/nz因为/c重复请求/gi导致/gi对/p数据库操作/gi出来/vf的/ude1数据/gi不是/c你/rr想要/v的/ude1那个/rz样子/n。/w比如/v，/w用户/gi签到/gi，/w你/rr只想/v让/v用户一天/nz签到/gi一次/nz，/w为了/p防止/gi签到/gi多/a次/qv，/w你/rr对于/p每次/r强求/v，/w都/d去/vf查询数据库/n今天/t是不是/v已经/d签到/gi了/ule，/w如果/c签/v了/ule，/w就/d不让/v继续/v签到/gi，/w如果/c没/d签到/gi，/w插入/gi签到/gi数据/gi，/w更新/gi积分/n数据/gi什么/ry的/ude1。/w但是/c数据库操作/gi是/vshi有/vyou时间/gi的/ude1，/w在/p高并发/gi下/f这种/r方式/n明显/a是/vshi不能/v限制/vn重复请求/gi提交/gi的/ude1，/w有可能/nz一个/mq用户一天/nz签到/gi好几次/d，/w只要/c这个/rz提交/gi时间/gi在/p很短/d的/ude1范围内/nz就/d行/ng（/w亲测/nz确实/ad是/vshi这样/rzv的/ude1）/w。/w  /x于是/cc就/d引出/v了/ule今天/t要/v讨论/gi的/ude1问题/gi，/w如何/ryv处理/vn重复/gi提交/gi的/ude1问题/gi。/w  /x首先/d看看/v准确/a的/ude1出现/v重复请求/gi问题/gi的/ude1原因/n（/w容/v老夫/rctrlv/nz一段/nz文字/gi)/nz：/w  /x在/p业务/gi开发/gi中/f，/w我们/rr常会/n面对/v防止/gi重复请求/gi的/ude1问题/gi。/w当/p服务端/nz对于/p请求/gi的/ude1响应/v涉及/v数据/gi的/ude1修改/gi，/w或/c状态/gi的/ude1变更/gi时/qt，/w可能会/nz造成/v极大/a的/ude1危害/gi。/w重复请求/gi的/ude1后果/gi在/p交易系统/nz、/w售后/vi维权/n，/w以及/cc支付/gi系统/gi中/f尤其/d严重/a。/w前台/n操作/gi的/ude1抖动/v，/w快速/d操作/gi，/w网络通信/gi或者/c后端/f响应/v慢/a，/w都会/n增加/v后端/f重复/gi处理/vn的/ude1概率/gi。/w前台/n操作/gi去/vf抖动/v和/cc防/v快速/d操作/gi的/ude1措施/gi，/w我们/rr首先/d会/v想到/v在/p前端/gi做/v一层/nz控制/vn。/w当前/t端/v触发/gi操作/gi时/qt，/w或/c弹出/vf确认/v界面/gi，/w或/cdisable/nz入口/n并/cc倒计时/l等等/udeng，/w此处/s不/d细表/nz。/w但/c前端/gi的/ude1限制/vn仅/d能/v解决/v少/a部分/n问题/gi，/w且/c不够/a彻底/ad，/w后端/f自有/b的/ude1防/v重复/gi处理/vn措施/gi必不可少/vl，/w义不容辞/vl。/w嗯/e，/w嗦/nz的/ude1原因/n交代/v完毕/vi，/w下面/f来讲/uls讲/v具体/a的/ude1solution/nz：/w /x我们/rr说/v是/vshi基于/predis/gi缓存/gi的/ude1处理/vn重复请求/gi的/ude1方式/n，/w重复请求/gi就是/v在/p很短/d的/ude1时间/gi内/f发送/gi多/a次/qv请求/gi，/w这个/rz时间/gi是/vshi相当/d短/a的/ude1，/w以至于/c你/rr进行/vn数据库/gi查询/gi来/vf验证/v都/d没法/v取/v阻挡/v。/w这样的话/l，/w我们/rr就/d可以/v使用/gi一个/mq缓存/gi的/ude1计数器/gi来/vf阻止/v这个/rz问题/gi的/ude1发生/v。/w在/p接口/gi的/ude1开始/v，/w定义/gi一个/mq缓存/gi计数器/gi（/w该/rz缓存/gi的/ude1时间/gi可以/v是/vshi几/d秒/qt，/w几/d十秒/nz或者/c一/nz两/nz分钟/qt，/w能/v完成/v短时间/nz内/f多/a个/q请求/gi的/ude1这个/rz短时间/nz的/ude1时间/gi就/d行/ng）/w，/w同一个/b会员/nnt的/ude1每个/r进来/vf一个/mq请求/gi就/d将/d这个/rz计数器/gi1/nz（/w当然/d就是/v用/p会员/nnt的/ude1id/nz一/nz些/q特定/b的/ude1字符串/gi做/vkey/gi）/w，/w对于/p大于/v1/nz的/ude1请求/gi不予/v受理/v。/w这样/rzv在/p这个/rz缓存/gi进行/vn的/ude1时间段/gi内/f就/d能/v唯一/b确保/v只有/c一个/mq。/w嗯/e，/w具体/a的/ude1实现/gi方式/n就是/v这样/rzv。/w（/w亲测/nz有效/gi）/w /x下面/f推荐/gi几/d种/q处理方式/n（/w基本上/d还是/credis/gi缓存机制/gi最好/d，/w当然/d我/rr也/d是/vshi主要/b从/p这里/rzs借鉴/gi的/ude1）/w：/w /x