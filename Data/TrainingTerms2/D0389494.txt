#spring aop/nz的/ude1实现/gi方式/n（/w一/nz）/w
  spring aop/nz是/vshi一种/nz面向/v切面/gi的/ude1编程/gi思想/gi,/nz我们/rr知道/vaop/gi的/ude1应用场景/gi，/w例如/v事务处理/nz、/w日志/gi、/w缓存/gi等/udeng，/w但是/c很/d多/a人/n对/paop/gi的/ude1原理/gi并/cc不是/c很/d了解/v。/w这里/rzs我们/rr讲述/v一下/m为什么/ryv使用/giaop/gi和/cc怎么/ryv使用/giaop/gi的/ude1简单/a使用/gi。/waop/gi定义/gi /x面向/v切面/gi编程/gi是/vshi对/p程序/gioop/nz编程/gi的/ude1另一种/nz补充/vn。/woo/nz将/d应用程序/nz分解/gi为/p对象/gi层次/n，/w而/ccaop/gi则/d将/d程序/gi分解/gi为/p各个方面/l或者/c关系/gi。/w这/rzv就/d使得/vi模块/gi之间/f的/ude1关联/vn能够/v跨/v多/a个/q对象/gi进行/vn处理/vn。/waop/gi的/ude1出现/v /x我们/rr先/d看看/v我们/rr的/ude1案例/gi，/w事务处理/nz、/w日志/gi、/w缓存/gi，/w我们/rr看看/v事务/gi是/vshi如何/ryv使用/giaop/gi的/ude1。/w事务处理/nz  /x事务处理/nz，/w我们/rr在/p操作/gi数据库/gi的/ude1时候/n需要/v进行/vntry/nzC/nzcatch/nz,/nz如果/c有/vyou异常/gi则/d需要/v我们/rr的/ude1事务/gi进行/vn会/v滚/vi操作/gi，/w但是/c我们/rr无需/v知道/v数据库/gi做/v了/ule什么/ry操作/gi,/nz我们/rr只要/c知道/v是否/v发生/v了/ule异常/gi,/nz如若/c发生/v异常/gi，/w则/d回滚/gi，/w如/v图/gi：/wcreated with rapha/nz?/nzl /nz2.1.0/nz开始/v新增/v保存/gi点/gi数据库操作/gi发生/v异常/gi？/w回/v滚到/v保存/gi点/gi提交/gi事务/giyesno  /nz我们/rr从/p图/gi中/f可以/v看出/v，/w整个/b控制/vn流程/gi的/ude1关键在于/n是否/v发生/v异常/gi，/w如果/c发生/v异常/gi的话/udh直接/ad回滚/gi，/w否则/c提交/gi事务/gi，/w也/d就是说/c我们/rr无需/v关注/v数据库/gi做/v了/ule什么/ry，/w我们/rr只要/c在/p开始/v的/ude1时候/nsavepoint/nz，/w最后/f判断/gi是否/v发生/v异常/gi，/w如果/c异常/gi了/ulecallback /nz，/w否则/c就/dcommit/nz。/w /x每次/r都/d要/v做/v重复/gi的/ude1savepoint/nz，/w然后/ccallback /nz、/wcommit/nz，/w所以/c我们/rr使用/giaop/gi来/vf简化/gi工作/gi。/w日志/gi处理/vn  /x日志/gi处理/vn，/w我们/rr在/p日常/b系统/gi操作/gi中/f，/w往往/d需要/v记录/gi一/nz些/q操作/gi日志/gi，/w来/vf判断/gi用户/gi的/ude1使用/gi情况/n，/w是否/v使用/gi正确/a。/w记录/gi用户/gi、/wip/gi、/w使用/gi情况/n等/udeng。/w需要/v我们/rr使用/gi日志/gi来/vf单独/d处理/vn，/w这里/rzs使用/gi我们/rraop/gi的/ude1思想/gi也/d很/d简单/a，/w我们/rr在/p用户/gi操作/gi之前/f和/cc用户/gi操作/gi之后/f记录/gi日志/gi。/w        /x这里/rzs有人/r会/v问/v了/ule，/w我/rr直接/ad在/p方法/gi之前/f写/v一个/mq记录/gi函数/gi，/w操作/gi完成/v之后/f也/d写/v一个/mq记录/gi函数/gi就/d可以/v了/ule呀/y？/w答案/gi是/vshi没错/vi，/w你/rr完全/ad实现/gi了/ule效果/gi，/w那/rzv如果/c我/rr需要/v在/p我/rr这/rzv上/f百个/q函数/gi中都/ns需要/v加入/v这样/rzv的/ude1函数/gi，/w那/rzv你/rr还/d会/v这么/rz去/vf做/v么/y？/w写/v太多/ad了/ule，/w我们/rr就/d又/d要/v重构/gi了/ule./nz我们/rr重构/gi的/ude1目的/gi就是/v不让/v同样/d的/ude1工作/gi去/vf重复/gi工作/gi，/w这/rzv就是/v重构/gi。/wcreated with rapha/nz?/nzl /nz2.1.0/nz开始/v记录/gi开始/v日志/gi业务操作/gi记录/gi结束/v日志/gi结束/v  /x从/p图/gi中/f我们/rr可以/v看到/v，/w我们/rr不用/d关心/v业务/gi做/v什么/ry，/w我们/rr只要/c把/pbalog/gi记录/gi就/d可以/v了/ule，/w这里/rzs跟/p事务处理/nz一样/uyy的/ude1处理方式/n，/w只要/c把/pba开头/n和/cc结尾/n处理/vn好/a就/d可以/v了/ule。/w