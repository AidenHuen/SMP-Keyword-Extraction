#二叉树/gi的/ude1各种/rz遍历/gi算法/gi
二叉树/gi（/w二叉搜索树/gi）/w的/ude1遍历/gi算是/v相当/d经典/gi了/ule，/w如/v前序/n遍历/gi、/w中/f序/n遍历/gi、/w后序/n遍历/gi，/w即/v可以/v用/p递归/gi的/ude1方式/n实现/gi，/w也/d可以/v用/p迭代/gi的/ude1方式/n实现/gi，/w还有/v诸如/v层次遍历/gi、/w线索/n遍历/gi等/udeng，/w这些/rz算法/gi构成/v了/ule相当/d一/nz部分/n面试题/n的/ude1基础/gi。/w1/nz、/w前序/n遍历/gi的/ude1递归实现/gi，/w代码/gi如下/vi：/w2/nz、/w中/f序/n遍历/gi的/ude1递归实现/gi，/w代码/gi如下/vi：/w3/nz、/w后序/n遍历/gi的/ude1递归实现/gi，/w代码/gi如下/vi：/w上述/b三种/nz递归/gi方式/n非常简单/nz，/w三者/r之间/f的/ude1唯一/b区别/gi就是/vres/nz./nzpush/nz_/nzback/nz(/nz)/nz这/rzv句话/q的/ude1位置/gi：/w放在/v最/d前面/f就是/v前序/n遍历/gi，/w放在/v中间/f就是/v中序/nz遍历/gi，/w放在/v后面/f就是/v后序/n遍历/gi。/w4/nz、/w前序/n遍历/gi的/ude1迭代/gi实现/gi，/w需要/v要到/v一个栈/nz，/w每次/r访问/gi完根/nz节点/gi，/w把/pba它/rr的/ude1右子/nz节点/gi、/w左子/nz节点/gi分别/d压/v入栈/nz中/f，/w代码/gi如下/vi：/w5/nz、/w中/f序/n遍历/gi的/ude1迭代/gi实现/gi，/w需要/v用/p到/v一个栈/nz和/cc一个/mq额外/b的/ude1指针/gicurrent/nz，/wcurrent/nz指向/v当前/t的/ude1节点/gi，/w如果/c当前/t节点/gi有/vyou左子/nz节点/gi，/w则/d把/pba当前/t节点/gi压/v入栈/nz中/f，/w并/cc把/pbacurrent/nz指向/v其/rz左子/nz节点/gi，/w如果/c当前/t节点/gi没有/v左子/nz节点/gi，/w则/d从/p栈顶/nz取出/v一个/mq元素/gi并/cc访问/gi，/w然后/c将/dcurrent/nz指向/v当前/t节点/gi的/ude1右子/nz节点/gi，/w代码/gi如下/vi：/w6/nz、/w后序/n遍历/gi的/ude1迭代/gi实现/gi，/w先/d介绍/gi一种/nz非常/d灵巧/a的/ude1方法/gi，/w后序/n遍历/gi的/ude1遍历/gi顺序/gi是/vshi：/w左/fC/nz右/fC/nz根/n，/w而/cc前序/n遍历/gi的/ude1顺序/gi是/vshi：/w根/nC/nz左/fC/nz右/f，/w其实/d可以/v很容易/nz地/ude2把/pba前序/n遍历/gi的/ude1代码/gi改造/vn成/v：/w根/nC/nz右/fC/nz左/f，/w这样/rzv遍历/gi的/ude1结果/n正好/z是/vshi后序/n遍历/gi的/ude1逆/vg，/w所以/c把/pba结果/n翻转/gi一/nz下/f就行了/l，/w代码/gi如下/vi：/w后序/n遍历/gi的/ude1另一种/nz实现/gi与/cc中序/nz遍历/gi的/ude1思路/gi类似/a，/w也/d是/vshi把/pba当前/t节点/gi压入/nz栈中/nz（/w不/d压/v入/v右子/nz节点/gi）/w，/w不过/c，/w如果/c当前/t节点/gi没有/v左子/nz节点/gi，/w也/d不能/v立马/d访问/gi当前/t节点/gi，/w所以/c还要/d再次/d把/pba其/rz压/v入栈/nz中/f，/w等/udeng访问/gi完/vi它/rr的/ude1右子/nz节点/gi，/w才能/n把/pba当前/t节点/gi取出/v来/vf并/cc访问/gi，/w（/w一个/mq节点/gi会/v两/nz次/qv出栈/nz，/w只有/c第二次/nz出栈/nz才/d可以/v访问/gi）/w代码/gi如下/vi：/w7/nz、/w层次遍历/gi i/nz，/w即/v从上到下/nz，/w一层一层/nz地/ude2遍历/gi，/w而且/c每一层/nz是从/v左/f到/v右/f遍历/gi，/w需要/v用/p到/v一个/mq队列/gi，/w代码/gi如下/vi：/w8/nz、/w层次遍历/gi ii/nz，/w即/v“/w之/uzhi”/w字形/n遍历/gi，/w第一层/nz从左到右/nz，/w第二层/nz从右到左/nz，/w第三层/nz从左到右/nz…/w…/w，/w代码/gi如下/vi：/w9/nz、/w线索/n化/v的/ude1中序/nz遍历/gi，/w空间/n复杂度/gi为/po/nz(/nz1/nz)/nz，/w但是/c有些/rz节点/gi会/v遍历/gi两/nz次/qv，/w基本/a思想/gi是/vshi：/w如果/c当前/t指针/gi的/ude1左子/nz节点/gi为/p空/ng，/w则/d访问/gi当前/t节点/gi，/w否则/c寻找/v当前/t节点/gi在/p中/f序/n遍/qv历下/nz的/ude1前驱/n节点/gi，/w并/cc把/pba前驱/n节点/gi的/ude1右/f指针/gi指向/v自己/rr…/w…/w看/v代码/gi可能/v更容易/nz懂/v一/nz些/q，/w代码/gi如下/vi：/w